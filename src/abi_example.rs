use alloy_primitives::{Address, U256};
use alloy_sol_types::{sol, SolCall, SolInterface};
use std::error::Error;
use std::fs;

fn main() -> Result<(), Box<dyn Error>> {
    // Method 1: Directly define the interface in the sol! macro
    // This is what we did in main.rs
    // sol! {
    //     #[derive(Debug, PartialEq)]
    //     interface USDC {
    //         function transfer(address to, uint256 value) external returns (bool);
    //         function approve(address spender, uint256 value) external returns (bool);
    //     }
    // }

    // Method 2: Read the ABI from a file and use it to generate the interface
    // Read the ABI file
    let abi_json = fs::read_to_string("src/abi.json")?;
    
    // Parse the ABI into a JsonAbi object
    let abi: alloy_json_abi::JsonAbi = serde_json::from_str(&abi_json)?;
    
    // Find specific functions in the ABI
    let transfer_function = abi.functions()
        .find(|f| f.name == "transfer")
        .expect("transfer function not found in ABI");
    
    let approve_function = abi.functions()
        .find(|f| f.name == "approve")
        .expect("approve function not found in ABI");
    
    println!("Found transfer function in ABI: {}", transfer_function.signature());
    println!("Found approve function in ABI: {}", approve_function.signature());
    
    // Example transaction data
    let transfer_data = alloy_primitives::hex!("a9059cbb0000000000000000000000008bc47be1e3abbaba182069c89d08a61fa6c2b2920000000000000000000000000000000000000000000000000000000253c51700");
    
    // Decode using the interface generated by sol! macro
    // let decoded_transfer = USDC::USDCCalls::abi_decode(&transfer_data, true)?;
    // println!("Decoded using sol! macro: {:?}", decoded_transfer);
    
    // Method 3: For a more dynamic approach, you can also use the JsonAbi directly
    // Extract the function selector (first 4 bytes)
    let selector = &transfer_data[0..4];
    
    // Find the function in the ABI by its selector
    let function = abi.functions()
        .find(|f| f.selector() == selector)
        .expect("Function not found for selector");
    
    println!("Found function by selector: {}", function.signature());
    
    // The Function type doesn't have a decode_input method directly
    // We need to use a different approach to decode the inputs
    // For this example, we'll just print the function information
    println!("Function inputs:");
    for input in &function.inputs {
        println!("  {} ({})", input.name, input.ty);
    }
    
    // Note: To properly decode the inputs, you would typically use the SolType trait
    // This is a simplified example
    
    // We've already printed the function inputs above
    
    Ok(())
}
